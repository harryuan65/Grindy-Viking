###### tags: `BFS`

# 01 Matrix

!!! question [題目](https://leetcode.com/problems/01-matrix)
    給一個由 0、1 組成的 2D Array，將每個元素改成「它與0的最近距離」。
    EX:
    ```ruby
    Input: 
    [
      [0, 0, 0], 
      [0, 1, 0], 
      [1, 1, 1]
    ]
    Output:
    [
      [0, 0, 0], 
      [0, 1, 0], 
      [1, 2, 1]
    ]
    ```
第一時間想不到，所以參考了別人的答案：
- 先走過整個 2D Array
  - 是 0 的位置丟到 Queue 裡面。
  - 是 1 就將它標記為 `#` （隨便一個符號，代表等一下要檢查）
- 把每個 Queue 位置走過一次：
  - 檢查上、下、左、右，是否== `#`，是的話就
    - 將該位置設為 目前 queue 檢查的位置值 + 1 (跟他距離一步)
    - 將該位置排到 Queue 後面（等下要再回來檢查它四周）

## Example Step

<style>
th, td { 
  font-weight: 100 !important;
  width: 50px;
  height: 50px;  
  text-align:center;
}
</style>

| 0   | 0   | 0   |
| --- | --- | --- |
| 0   | 1   | 0   |
| 1   | 1   | 1   |

1. 所有零的位置依序丟到 Queue
2. 將 1 標記成「尚未探測過的點」
3. for (i,j) in queue 每個點 i, j
   檢查 i, j 上下左右是否還沒標記的點
   1. 更新他的值
   2. Push 到 queue 後面
  
---

**(0,0)** , (0,1) , (0,2) , (1,0) , (1,2)

| **0** | 0   | 0   |
| ----- | --- | --- |
| 0     | #   | 0   |
| #     | #   | #   |

Do nothing

---

(0,0) , **(0,1)** , (0,2) , (1,0) , (1,2)

| 0   | **0** | 0   |
| --- | ----- | --- |
| 0   | #     | 0   |
| #   | #     | #   |

| 0   | **0** | 0   |
| --- | ----- | --- |
| 0   | `1`   | 0   |
| #   | #     | #   |

push 到 Queue
~ (0,0) , (0,1) , (0,2) , (1,0) , (1,2), `(1,1)`

---

(0,0) , (0,1) , **(0,2)** , (1,0) , (1,2), (1,1)

| 0   | 0   | **0** |
| --- | --- | ----- |
| 0   | 1   | 0     |
| #   | #   | #     |
 
Do nothing

---

(0,0) , (0,1) , (0,2) , **(1,0)** , (1,2), (1,1)

| 0     | 0   | 0   |
| ----- | --- | --- |
| **0** | 1   | 0   |
| #     | #   | #   |

| 0     | 0   | 0   |
| ----- | --- | --- |
| **0** | 1   | 0   |
| `1`   | #   | #   |

push 到 queue
~ (0,0) , (0,1) , (0,2) , (1,0) , (1,2), (1,1), `(2,1)`

---

(0,0) , (0,1) , (0,2) , (1,0) , **(1,2)**, (1,1), (2,1)

| 0   | 0   | 0     |
| --- | --- | ----- |
| 0   | 1   | **0** |
| 1   | #   | #     |

| 0   | 0   | 0     |
| --- | --- | ----- |
| 0   | 1   | **0** |
| 1   | #   | `1`   |

push 到 queue
~ (0,0) , (0,1) , (0,2) , (1,0) , (1,2), (1,1), (2,1), `(2,2)`

---

(0,0) , (0,1) , (0,2) , (1,0) , (1,2), **(1,1)**, (2,1), (2,2)
| 0   | 0     | 0   |
| --- | ----- | --- |
| 0   | **1** | 0   |
| 1   | #     | 1   |

| 0   | 0     | 0   |
| --- | ----- | --- |
| 0   | **1** | 0   |
| 1   | `2`   | 1   |

push 到 queue
~ (0,0) , (0,1) , (0,2) , (1,0) , (1,2), (1,1), (2,1), (2,2), `(2,1)`

---

(0,0) , (0,1) , (0,2) , (1,0) , (1,2), (1,1), **(2,1)**, (2,2), (2,1)

| 0   | 0     | 0   |
| --- | ----- | --- |
| 0   | 1     | 0   |
| 1   | **2** | 1   |

Do nothing

---

(0,0) , (0,1) , (0,2) , (1,0) , (1,2), (1,1), (2,1), **(2,2)**, (2,1)

| 0   | 0   | 0     |
| --- | --- | ----- |
| 0   | 1   | 0     |
| 1   | 2   | **1** |

Do nothing

---

(0,0) , (0,1) , (0,2) , (1,0) , (1,2), (1,1), (2,1), (2,2), **(2,1)**

| 0   | 0     | 0   |
| --- | ----- | --- |
| 0   | 1     | 0   |
| 1   | **2** | 1   |

Do nothing

---

Done

## Solution

```ruby
def update_matrix(mat)
  queue = []

  0.upto(mat.size - 1) do |i|
    0.upto(mat[i].size - 1) do |j|
      if mat[i][j].zero?
        queue << [i, j]
      else
        mat[i][j] = '#'
      end
    end
  end

  directions = [[0, -1], [-1, 0], [0, 1], [1, 0]]
  queue.each do |src_i, src_j|
    directions.each do |dir_i, dir_j|
      check_i = src_i + dir_i
      check_j = src_j + dir_j

      next unless valid?(check_i, check_j, mat) && mat[check_i][check_j] == '#'

      mat[check_i][check_j] = mat[src_i][src_j] + 1
      queue << [check_i, check_j]
    end
  end
  mat
end

def valid?(i, j, mat)
  i < mat.size && i >= 0 && j < mat[i].size && j >= 0
end
```

Runtime: 668 ms, faster than 57.50% of Ruby online submissions for 01 Matrix.
Memory Usage: 214.1 MB, less than 57.50% of Ruby online submissions for 01 Matrix.